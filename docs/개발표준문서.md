# ROIMSG 개발표준문서

## 목차
1. [코딩 컨벤션](#1-코딩-컨벤션)
2. [아키텍처 패턴](#2-아키텍처-패턴)
3. [보안 가이드라인](#3-보안-가이드라인)
4. [데이터베이스 설계 원칙](#4-데이터베이스-설계-원칙)
5. [API 설계 원칙](#5-api-설계-원칙)
6. [에러 처리](#6-에러-처리)
7. [테스트 작성 가이드](#7-테스트-작성-가이드)
8. [Git 사용 규칙](#8-git-사용-규칙)
9. [코드 리뷰 가이드](#9-코드-리뷰-가이드)
10. [성능 최적화](#10-성능-최적화)

---

## 1. 코딩 컨벤션

### 1.1. Java (백엔드)

#### 네이밍 규칙

```java
// 클래스명: PascalCase
public class UserService { }
public class AuthController { }

// 메서드명: camelCase (동사로 시작)
public User findUserById(UUID id) { }
public void deleteUser(UUID id) { }
public boolean isUserActive(UUID id) { }

// 변수명: camelCase
private String userName;
private int userAge;

// 상수: UPPER_SNAKE_CASE
public static final String DEFAULT_ROLE = "USER";
public static final int MAX_RETRY_COUNT = 3;

// 패키지명: 소문자, 도메인 역순
package com.roimsg.auth.service;
package com.roimsg.user.repository;
```

#### 코드 스타일

```java
// 1. 한 줄에 하나의 문장
String name = user.getName();
int age = user.getAge();

// 2. 중괄호는 항상 사용 (한 줄이어도)
if (user != null) {
    return user.getName();
}

// 3. else-if 사용 시 개행
if (condition1) {
    // ...
} else if (condition2) {
    // ...
} else {
    // ...
}

// 4. 메서드 체이닝 시 개행
userRepository
    .findById(userId)
    .orElseThrow(() -> new UserNotFoundException("User not found"));

// 5. 람다식은 명확하게
users.stream()
    .filter(user -> user.isActive())
    .map(user -> user.getName())
    .collect(Collectors.toList());
```

#### 주석 작성

```java
/**
 * 사용자를 조회합니다.
 * 
 * @param userId 사용자 ID
 * @param tenantId 테넌트 ID
 * @return 사용자 정보
 * @throws UserNotFoundException 사용자를 찾을 수 없는 경우
 */
public User findUser(UUID userId, UUID tenantId) {
    // 테넌트 검증
    validateTenant(tenantId);
    
    // 사용자 조회
    return userRepository.findByIdAndTenantId(userId, tenantId)
        .orElseThrow(() -> new UserNotFoundException("User not found"));
}

// TODO: 캐싱 적용 필요
// FIXME: 성능 개선 필요
// HACK: 임시 해결 방법
```

### 1.2. TypeScript/Vue (프론트엔드)

#### 네이밍 규칙

```typescript
// 컴포넌트명: PascalCase
export default defineComponent({
  name: 'UserProfile',
});

// 변수/함수명: camelCase
const userName: string = 'John';
const fetchUserData = async (): Promise<User> => { };

// 상수: UPPER_SNAKE_CASE
const MAX_FILE_SIZE = 10 * 1024 * 1024;
const API_BASE_URL = 'http://localhost:8080';

// 타입/인터페이스: PascalCase
interface User {
  id: string;
  name: string;
}

type UserRole = 'ADMIN' | 'USER' | 'GUEST';

// 파일명
// 컴포넌트: PascalCase.vue
// 유틸리티: camelCase.ts
UserProfile.vue
auth.ts
api.ts
```

#### Vue 컴포넌트 구조

```vue
<template>
  <!-- 1. 루트 요소는 하나만 -->
  <div class="user-profile">
    <!-- 2. v-if와 v-for 동시 사용 금지 -->
    <template v-if="isLoading">
      <LoadingSpinner />
    </template>
    
    <!-- 3. 이벤트 핸들러는 명확하게 -->
    <button @click="handleSubmit">제출</button>
  </div>
</template>

<script setup lang="ts">
// 1. Import 순서
// - Vue 관련
import { ref, computed, onMounted } from 'vue';
// - 외부 라이브러리
import axios from 'axios';
// - 내부 모듈
import { User } from '@/types/user';
import { useAuthStore } from '@/stores/auth';

// 2. Props 정의
interface Props {
  userId: string;
  showDetails?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  showDetails: true,
});

// 3. Emits 정의
const emit = defineEmits<{
  (e: 'update', user: User): void;
  (e: 'delete', userId: string): void;
}>();

// 4. Composables 사용
const authStore = useAuthStore();

// 5. Reactive 상태
const user = ref<User | null>(null);
const isLoading = ref(false);

// 6. Computed
const displayName = computed(() => {
  return user.value?.name ?? '알 수 없음';
});

// 7. Methods
const fetchUser = async () => {
  isLoading.value = true;
  try {
    const response = await axios.get(`/api/users/${props.userId}`);
    user.value = response.data;
  } catch (error) {
    console.error('Failed to fetch user:', error);
  } finally {
    isLoading.value = false;
  }
};

const handleSubmit = () => {
  if (user.value) {
    emit('update', user.value);
  }
};

// 8. Lifecycle Hooks
onMounted(() => {
  fetchUser();
});
</script>

<style scoped lang="scss">
.user-profile {
  padding: 16px;
  
  &__title {
    font-size: 20px;
    font-weight: bold;
  }
}
</style>
```

### 1.3. SQL

```sql
-- 1. 키워드는 대문자
SELECT id, name, email
FROM users
WHERE tenant_id = :tenantId
  AND is_active = TRUE
ORDER BY created_at DESC
LIMIT 10;

-- 2. 테이블명: snake_case
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 3. 인덱스명: idx_{테이블}_{컬럼}
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_posts_board_id_created_at ON posts(board_id, created_at DESC);

-- 4. 외래키명: fk_{테이블}_{참조테이블}
ALTER TABLE posts
ADD CONSTRAINT fk_posts_users
FOREIGN KEY (author_id) REFERENCES users(id);
```

---

## 2. 아키텍처 패턴

### 2.1. 계층형 아키텍처 (Layered Architecture)

```
Controller/API Layer
        ↓
Service/Business Layer
        ↓
Repository/Data Access Layer
        ↓
Database
```

**각 계층의 책임:**

```java
// 1. Controller Layer: 요청/응답 처리
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{userId}")
    public ResponseEntity<UserResponse> getUser(@PathVariable UUID userId) {
        User user = userService.findUser(userId);
        UserResponse response = UserMapper.toResponse(user);
        return ResponseEntity.ok(response);
    }
}

// 2. Service Layer: 비즈니스 로직
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User findUser(UUID userId) {
        return userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("User not found"));
    }
    
    public User updateUser(UUID userId, UserUpdateRequest request) {
        User user = findUser(userId);
        user.setName(request.getName());
        user.setPhoneNumber(request.getPhoneNumber());
        return userRepository.save(user);
    }
}

// 3. Repository Layer: 데이터 액세스
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {
    Optional<User> findByTenantIdAndEmail(UUID tenantId, String email);
    List<User> findByTenantIdAndIsActive(UUID tenantId, Boolean isActive);
}
```

### 2.2. DTO 패턴

```java
// Request DTO
public class UserUpdateRequest {
    @NotBlank(message = "이름은 필수입니다")
    private String name;
    
    @Pattern(regexp = "^01[0-9]-[0-9]{4}-[0-9]{4}$", message = "올바른 전화번호 형식이 아닙니다")
    private String phoneNumber;
    
    // Getters, Setters
}

// Response DTO
public class UserResponse {
    private String id;
    private String name;
    private String email;
    private String profileImageUrl;
    private LocalDateTime createdAt;
    
    // Getters, Setters
}

// Mapper
public class UserMapper {
    public static UserResponse toResponse(User user) {
        UserResponse response = new UserResponse();
        response.setId(user.getId().toString());
        response.setName(user.getName());
        response.setEmail(user.getEmail());
        response.setProfileImageUrl(user.getProfileImageUrl());
        response.setCreatedAt(user.getCreatedAt());
        return response;
    }
}
```

### 2.3. 멀티테넌시 패턴

```java
// 1. Tenant Context 관리
public class TenantContext {
    private static final ThreadLocal<UUID> currentTenant = new ThreadLocal<>();
    
    public static void setTenantId(UUID tenantId) {
        currentTenant.set(tenantId);
    }
    
    public static UUID getTenantId() {
        return currentTenant.get();
    }
    
    public static void clear() {
        currentTenant.remove();
    }
}

// 2. Tenant Filter
@Component
public class TenantFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) {
        try {
            String tenantId = request.getHeader("X-Tenant-Id");
            if (tenantId != null) {
                TenantContext.setTenantId(UUID.fromString(tenantId));
            }
            filterChain.doFilter(request, response);
        } finally {
            TenantContext.clear();
        }
    }
}

// 3. JPA Filter 자동 적용
@Entity
@FilterDef(name = "tenantFilter", parameters = @ParamDef(name = "tenantId", type = "uuid"))
@Filter(name = "tenantFilter", condition = "tenant_id = :tenantId")
public class User {
    @Id
    private UUID id;
    
    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
    
    // ...
}
```

---

## 3. 보안 가이드라인

### 3.1. KISA 보안 가이드라인 준수

#### 입력 데이터 검증

```java
// 1. SQL Injection 방지
// ❌ 나쁜 예
String query = "SELECT * FROM users WHERE email = '" + email + "'";

// ✅ 좋은 예
@Query("SELECT u FROM User u WHERE u.email = :email")
Optional<User> findByEmail(@Param("email") String email);

// 2. XSS 방지
// ❌ 나쁜 예
return "<div>" + userInput + "</div>";

// ✅ 좋은 예
import org.springframework.web.util.HtmlUtils;
return "<div>" + HtmlUtils.htmlEscape(userInput) + "</div>";

// 3. 파일 업로드 검증
public class FileUploadValidator {
    private static final List<String> ALLOWED_EXTENSIONS = 
        Arrays.asList("jpg", "jpeg", "png", "gif", "pdf", "doc", "docx");
    
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    
    public void validate(MultipartFile file) {
        // 파일 크기 검증
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new FileSizeExceededException("파일 크기가 너무 큽니다");
        }
        
        // 확장자 검증
        String extension = getFileExtension(file.getOriginalFilename());
        if (!ALLOWED_EXTENSIONS.contains(extension.toLowerCase())) {
            throw new InvalidFileTypeException("허용되지 않은 파일 형식입니다");
        }
        
        // MIME 타입 검증
        String mimeType = file.getContentType();
        if (!isValidMimeType(mimeType)) {
            throw new InvalidFileTypeException("유효하지 않은 MIME 타입입니다");
        }
    }
}
```

#### 인증 및 권한

```java
// 1. JWT 토큰 검증
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) {
        String token = extractToken(request);
        
        if (token != null && jwtUtil.validateToken(token)) {
            UUID userId = jwtUtil.getUserIdFromToken(token);
            UUID tenantId = jwtUtil.getTenantIdFromToken(token);
            
            // SecurityContext에 인증 정보 설정
            Authentication auth = new UsernamePasswordAuthenticationToken(
                userId, null, Collections.emptyList());
            SecurityContextHolder.getContext().setAuthentication(auth);
            
            // Tenant Context 설정
            TenantContext.setTenantId(tenantId);
        }
        
        filterChain.doFilter(request, response);
    }
}

// 2. 권한 체크
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(UUID userId) {
    // 관리자만 실행 가능
}

@PreAuthorize("#userId == authentication.principal.id")
public User updateUser(UUID userId, UserUpdateRequest request) {
    // 본인만 수정 가능
}
```

#### 데이터 암호화

```java
// 1. 비밀번호 암호화 (BCrypt)
@Service
public class PasswordService {
    
    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    
    public String encryptPassword(String plainPassword) {
        return encoder.encode(plainPassword);
    }
    
    public boolean matches(String plainPassword, String encodedPassword) {
        return encoder.matches(plainPassword, encodedPassword);
    }
}

// 2. 민감 정보 암호화 (AES-256)
@Service
public class EncryptionService {
    
    @Value("${encryption.key}")
    private String encryptionKey;
    
    public String encrypt(String data) {
        try {
            SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encrypted = cipher.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception e) {
            throw new EncryptionException("암호화 실패", e);
        }
    }
    
    public String decrypt(String encryptedData) {
        // 복호화 로직
    }
}
```

### 3.2. HTTPS 강제 사용

```java
// Spring Security 설정
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .requiresChannel()
            .anyRequest()
            .requiresSecure()  // HTTPS 강제
            .and()
            .headers()
            .httpStrictTransportSecurity()
            .maxAgeInSeconds(31536000)  // HSTS 1년
            .includeSubDomains(true);
        
        return http.build();
    }
}
```

### 3.3. Rate Limiting

```java
// Redis를 사용한 Rate Limiting
@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final int MAX_REQUESTS = 100;
    private static final long TIME_WINDOW = 60; // 초
    
    @Override
    public boolean preHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler) throws Exception {
        String clientIp = getClientIp(request);
        String key = "rate_limit:" + clientIp;
        
        Long requests = redisTemplate.opsForValue().increment(key);
        
        if (requests == 1) {
            redisTemplate.expire(key, TIME_WINDOW, TimeUnit.SECONDS);
        }
        
        if (requests > MAX_REQUESTS) {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            return false;
        }
        
        return true;
    }
}
```

---

## 4. 데이터베이스 설계 원칙

### 4.1. 테이블 설계

```sql
-- 1. 기본키는 UUID 사용
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    email VARCHAR(255) NOT NULL,
    name VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uk_tenant_email UNIQUE (tenant_id, email)
);

-- 2. 모든 테이블에 생성/수정 시간 포함
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP

-- 3. 소프트 삭제를 위한 컬럼
deleted_at TIMESTAMP NULL
is_active BOOLEAN DEFAULT TRUE

-- 4. 감사(Audit) 컬럼
created_by UUID REFERENCES users(id)
updated_by UUID REFERENCES users(id)
```

### 4.2. 인덱스 전략

```sql
-- 1. 자주 조회되는 컬럼에 인덱스
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_users_email ON users(email);

-- 2. 복합 인덱스 (조회 조건이 여러 개일 때)
CREATE INDEX idx_posts_board_id_created_at 
ON posts(board_id, created_at DESC);

-- 3. 부분 인덱스 (조건부 인덱스)
CREATE INDEX idx_users_active 
ON users(tenant_id) 
WHERE is_active = TRUE;

-- 4. Full-text 검색 인덱스
CREATE INDEX idx_posts_title_content 
ON posts USING gin(to_tsvector('korean', title || ' ' || content));
```

### 4.3. 쿼리 최적화

```java
// 1. N+1 문제 방지 (Fetch Join 사용)
// ❌ 나쁜 예
@Query("SELECT p FROM Post p WHERE p.boardId = :boardId")
List<Post> findByBoardId(@Param("boardId") UUID boardId);
// 이후 p.getAuthor()를 호출하면 N+1 문제 발생

// ✅ 좋은 예
@Query("SELECT p FROM Post p JOIN FETCH p.author WHERE p.boardId = :boardId")
List<Post> findByBoardIdWithAuthor(@Param("boardId") UUID boardId);

// 2. 페이지네이션 사용
@Query("SELECT p FROM Post p WHERE p.boardId = :boardId ORDER BY p.createdAt DESC")
Page<Post> findByBoardId(@Param("boardId") UUID boardId, Pageable pageable);

// 3. Projection 사용 (필요한 컬럼만 조회)
public interface PostSummary {
    UUID getId();
    String getTitle();
    LocalDateTime getCreatedAt();
}

@Query("SELECT p.id as id, p.title as title, p.createdAt as createdAt " +
       "FROM Post p WHERE p.boardId = :boardId")
List<PostSummary> findPostSummariesByBoardId(@Param("boardId") UUID boardId);
```

---

## 5. API 설계 원칙

### 5.1. RESTful API 설계

```
HTTP Method    URL Pattern                         설명
-----------    --------------------------------    ------------------
GET            /api/v1/users                       사용자 목록 조회
GET            /api/v1/users/{userId}              사용자 상세 조회
POST           /api/v1/users                       사용자 생성
PUT            /api/v1/users/{userId}              사용자 전체 수정
PATCH          /api/v1/users/{userId}              사용자 부분 수정
DELETE         /api/v1/users/{userId}              사용자 삭제

GET            /api/v1/boards/{boardId}/posts      게시글 목록 조회
POST           /api/v1/boards/{boardId}/posts      게시글 작성
```

### 5.2. 응답 포맷 표준화

```java
// 성공 응답
@Getter
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private T data;
    private MetaData meta;
    
    @Getter
    @AllArgsConstructor
    public static class MetaData {
        private String timestamp;
        private String version;
    }
    
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(
            true,
            data,
            new MetaData(
                LocalDateTime.now().toString(),
                "1.0.0"
            )
        );
    }
}

// 에러 응답
@Getter
@AllArgsConstructor
public class ErrorResponse {
    private boolean success = false;
    private ErrorDetail error;
    
    @Getter
    @AllArgsConstructor
    public static class ErrorDetail {
        private String code;
        private String message;
        private String details;
    }
}
```

### 5.3. 버전 관리

```java
// URL 버전 관리
@RestController
@RequestMapping("/api/v1/users")
public class UserControllerV1 { }

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 { }

// 헤더 버전 관리 (선택사항)
@GetMapping(headers = "X-API-Version=1")
public ResponseEntity<UserResponse> getUserV1() { }
```

---

## 6. 에러 처리

### 6.1. 커스텀 예외

```java
// 1. 예외 계층 구조
public class BusinessException extends RuntimeException {
    private final String errorCode;
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
}

public class UserNotFoundException extends BusinessException {
    public UserNotFoundException(String message) {
        super("USER_001", message);
    }
}

public class InvalidCredentialsException extends BusinessException {
    public InvalidCredentialsException(String message) {
        super("AUTH_001", message);
    }
}
```

### 6.2. 전역 예외 처리

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFoundException(
            UserNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            new ErrorResponse.ErrorDetail(
                "USER_001",
                ex.getMessage(),
                null
            )
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            MethodArgumentNotValidException ex) {
        String details = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.joining(", "));
            
        ErrorResponse error = new ErrorResponse(
            new ErrorResponse.ErrorDetail(
                "VALIDATION_001",
                "입력값 검증 실패",
                details
            )
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
            new ErrorResponse.ErrorDetail(
                "SERVER_001",
                "서버 오류가 발생했습니다",
                ex.getMessage()
            )
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

---

## 7. 테스트 작성 가이드

### 7.1. 단위 테스트 (Unit Test)

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    @DisplayName("사용자 조회 성공")
    void findUser_Success() {
        // Given
        UUID userId = UUID.randomUUID();
        UUID tenantId = UUID.randomUUID();
        User user = new User(tenantId, "test@example.com", "Test User");
        user.setId(userId);
        
        when(userRepository.findByIdAndTenantId(userId, tenantId))
            .thenReturn(Optional.of(user));
        
        // When
        User result = userService.findUser(userId, tenantId);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getId()).isEqualTo(userId);
        assertThat(result.getName()).isEqualTo("Test User");
        verify(userRepository, times(1)).findByIdAndTenantId(userId, tenantId);
    }
    
    @Test
    @DisplayName("사용자 조회 실패 - 사용자 없음")
    void findUser_UserNotFound() {
        // Given
        UUID userId = UUID.randomUUID();
        UUID tenantId = UUID.randomUUID();
        
        when(userRepository.findByIdAndTenantId(userId, tenantId))
            .thenReturn(Optional.empty());
        
        // When & Then
        assertThatThrownBy(() -> userService.findUser(userId, tenantId))
            .isInstanceOf(UserNotFoundException.class)
            .hasMessage("User not found");
    }
}
```

### 7.2. 통합 테스트 (Integration Test)

```java
@SpringBootTest
@AutoConfigureMockMvc
@Transactional
class UserControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    @DisplayName("사용자 생성 API 테스트")
    void createUser_Success() throws Exception {
        // Given
        String requestBody = """
            {
                "email": "test@example.com",
                "name": "Test User"
            }
            """;
        
        // When & Then
        mockMvc.perform(post("/api/v1/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.data.email").value("test@example.com"))
            .andExpect(jsonPath("$.data.name").value("Test User"));
        
        // Verify
        Optional<User> savedUser = userRepository.findByEmail("test@example.com");
        assertThat(savedUser).isPresent();
    }
}
```

### 7.3. E2E 테스트 (프론트엔드)

```typescript
// Cypress를 사용한 E2E 테스트
describe('Login Flow', () => {
  beforeEach(() => {
    cy.visit('/login');
  });

  it('should login successfully with Google', () => {
    // Google 로그인 버튼 클릭
    cy.get('[data-test="google-login-btn"]').click();
    
    // Google 인증 완료 (Stub)
    cy.intercept('POST', '/api/auth/google/login', {
      statusCode: 200,
      body: {
        success: true,
        data: {
          accessToken: 'fake-access-token',
          user: {
            id: 'user-id',
            email: 'test@example.com',
            name: 'Test User'
          }
        }
      }
    });
    
    // 대시보드로 리다이렉트 확인
    cy.url().should('include', '/dashboard');
    cy.contains('Test User').should('be.visible');
  });
});
```

---

## 8. Git 사용 규칙

### 8.1. 브랜치 전략 (Git Flow)

```
main (프로덕션)
  │
  ├── develop (개발)
  │     │
  │     ├── feature/user-profile
  │     ├── feature/message-system
  │     └── feature/board-service
  │
  ├── release/v1.0.0 (릴리스 준비)
  │
  └── hotfix/critical-bug (긴급 수정)
```

### 8.2. 커밋 메시지 규칙

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Type:**
- `feat`: 새로운 기능 추가
- `fix`: 버그 수정
- `docs`: 문서 변경
- `style`: 코드 포맷팅 (기능 변경 없음)
- `refactor`: 코드 리팩토링
- `test`: 테스트 코드 추가/수정
- `chore`: 빌드 설정 등 기타 변경

**예시:**
```
feat(auth): Google OAuth 로그인 기능 추가

- Google OAuth 2.0 인증 플로우 구현
- JWT 토큰 발급 로직 추가
- 사용자 정보 자동 저장 기능

Closes #123
```

### 8.3. Pull Request 작성

```markdown
## 변경 사항
- Google OAuth 로그인 기능 추가
- JWT 토큰 발급 및 검증 로직 구현

## 테스트
- [x] 단위 테스트 통과
- [x] 통합 테스트 통과
- [x] 수동 테스트 완료

## 스크린샷 (필요시)
![screenshot](link-to-image)

## 관련 이슈
Closes #123
```

---

## 9. 코드 리뷰 가이드

### 9.1. 리뷰어 체크리스트

- [ ] 코드가 요구사항을 충족하는가?
- [ ] 코딩 컨벤션을 준수하는가?
- [ ] 보안 취약점이 없는가?
- [ ] 성능 이슈가 없는가?
- [ ] 테스트 코드가 충분한가?
- [ ] 문서화가 필요한 부분은 문서화되었는가?
- [ ] 에러 처리가 적절한가?
- [ ] 중복 코드는 없는가?

### 9.2. 리뷰 코멘트 예시

```
// 좋은 코멘트
"이 부분은 N+1 문제가 발생할 수 있습니다. Fetch Join을 사용하는 것이 어떨까요?"
"테스트 케이스에 예외 상황도 추가해주세요."

// 나쁜 코멘트
"이 코드는 잘못되었습니다."
"다시 작성하세요."
```

---

## 10. 성능 최적화

### 10.1. 데이터베이스 최적화

```java
// 1. Batch Insert 사용
@Autowired
private EntityManager entityManager;

public void saveUsers(List<User> users) {
    int batchSize = 50;
    for (int i = 0; i < users.size(); i++) {
        entityManager.persist(users.get(i));
        if (i % batchSize == 0 && i > 0) {
            entityManager.flush();
            entityManager.clear();
        }
    }
}

// 2. 쿼리 결과 캐싱
@Cacheable(value = "users", key = "#userId")
public User findUser(UUID userId) {
    return userRepository.findById(userId)
        .orElseThrow(() -> new UserNotFoundException("User not found"));
}

@CacheEvict(value = "users", key = "#userId")
public void updateUser(UUID userId, UserUpdateRequest request) {
    // 업데이트 로직
}
```

### 10.2. 프론트엔드 최적화

```vue
<script setup lang="ts">
// 1. Lazy Loading
const UserProfile = defineAsyncComponent(() =>
  import('./components/UserProfile.vue')
);

// 2. Computed 사용으로 불필요한 재계산 방지
const filteredUsers = computed(() => {
  return users.value.filter(user => user.isActive);
});

// 3. Virtual Scrolling (대량 데이터)
import { RecycleScroller } from 'vue-virtual-scroller';
</script>

<template>
  <!-- Virtual Scrolling -->
  <RecycleScroller
    :items="items"
    :item-size="50"
    key-field="id"
  >
    <template #default="{ item }">
      <div>{{ item.name }}</div>
    </template>
  </RecycleScroller>
</template>
```

---

**작성자:** ROIMSG Development Team  
**최종 수정일:** 2025-10-14  
**버전:** 1.0.0

